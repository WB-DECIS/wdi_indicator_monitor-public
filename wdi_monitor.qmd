---
title: "Monitoring for the World Development Indicators"
format:
  dashboard:
    scrolling: true
    nav-buttons: github
    github: "https://github.com/WB-DECIS/wdi_indicator_monitor"
    theme: lumen
logo: "images/WB-DEC-Data-horizontal-white-gradient-high.png"
fig-width: 10
fig-asp: 0.3
params:
  database: World Development Indicators
  unit: DECDG

resource_files:
- manifest.json
---

```{r}
#| label: load-packages
#| message: false

library(tidyverse)
library(readxl)
library(scales)
library(DT)
library(gt)
library(ggbeeswarm)
library(plotly)
library(downloadthis)
library(reactable)
library(htmltools)
library(shiny)

theme_set(theme_minimal(base_size = 24, base_family = "Andes Bold"))
```

```{r}
#| label: load-data
#| message: false

monitoring_data <- read_csv("data/wdic.csv")
score_table     <- read_csv("data/indicators_scoretable.csv") 
score_table     <- mutate(score_table, 
                          across(contains("_score_hybrid"), 
                                 ~ round(., 2)))
```

```{r}
#| label: set-inputs

time_period <- paste(lubridate::month(Sys.Date(), label=TRUE), lubridate::year(Sys.Date()))

#extract number of indicators
n_indicators <- monitoring_data %>% 
  nrow()

#extract number of years
min_year <- min(monitoring_data$yearfirst)
max_year <- max(monitoring_data$yearlatest)

#extract number of countries
n_countries <- max(monitoring_data$n_country)
```

#  {.sidebar}

This dashboard displays <br/> statistics for:

|              |                              |
|--------------|------------------------------|
| **Database** | `{r} params$database`        |
| **Unit**     | `{r} params$unit`            |
| **Month**    | `{r} time_period`            |

<h3> WDI Summary  </h3>

|              |                              |
|--------------|------------------------------|
| **Indicators** | `{r} scales::comma(n_indicators)` |
| **Years** | `{r} paste0(min_year, " - ", max_year)` |
| **Countries** | `{r} n_countries` |

<!-- <h3> Download the Data </h3> -->

```{r}
#download the data
score_table |> 
  select(-contains("score")) |> 
  select(-contains("mean")) |> 
  select(-c("uniquevisitors", 
            "pageviews", 
            "visitors")) |> 
  download_this(
    output_name      = "WDI Monitoring data set",
    output_extension = ".xlsx",
    button_label     = "Download indicator score",
    button_type      = "warning",
    has_icon         = TRUE,
    icon             = "fa fa-save")
```

# All

```{r}
#| label: all-values
#| results: hide

#metadata count
#count number of indicators failing on metadata
metadata_count <- score_table %>% 
  filter(metadata_fail != "No missing metadata") %>% 
  nrow()

#license count
#count number of indicators failing on license
license_count <- score_table %>% 
  filter(License.Type != "CC BY-4.0"|is.na(License.Type)) %>% 
  nrow()

# low user count
#count number of indicators failing on user metrics
user_count <- score_table %>% 
  filter(visitors < 50) %>% 
  nrow()

# country count
#count number of indicators failing on country coverage
country_count <- score_table %>% 
  filter(n_country < 50) %>% 
  nrow()

#time count
#count number of indicators failing on time coverage
time_count <- score_table %>% 
  filter(yearlatest < (lubridate::year(Sys.Date())-10)) %>% 
  nrow()

#set thresholds for color scoring of indicator counts
# 0 indicators is blue
# 0-100 indicators is yellow
# more than 100 indicators is red
warning <- "#A79011"
danger <-"#CA8181"
light <- "#7B98AD"

metadata_color <- case_when(
  between(metadata_count, 0, 100) ~ warning,
  metadata_count > 100 ~ danger,
  .default = light
  )

license_color <- case_when(
  between(license_count, 0, 100) ~ warning,
  license_count > 100 ~ danger,
  .default = light
  )

user_color <- case_when(
  between(user_count, 0, 100) ~ warning,
  user_count > 100 ~ danger,
  .default = light
  )

country_color <- case_when(
  between(country_count, 0, 100) ~ warning,
  country_count > 100 ~ danger,
  .default = light
  )

time_color <- case_when(
  between(time_count, 0, 100) ~ warning,
  time_count > 100 ~ danger,
  .default = light
  )

### Summary card style 
card_style <- "text-decoration: none; color: inherit;"
icon_style <- "display: block; margin-top:20px;  text-align: center"
card_p_style <- "font-size: 18px;font-color: #ffffff; margin-top: 10px;text-align: left;line-height: 1.2;"
card_b_style <- "font-size: 2.5rem; font-color: #ffffff; margin: 0; text-align: left;font-weight: normal;"

```

```{r globals, include=FALSE}
# Vector of eligible columns

# # Store all eligible columns (including 'yearfirst') in a vector
var_selection <- 
  c("yearfirst", 
    "total_obs", 
    "n_years", 
    "countryobs_avg",
    "countryobs_max",
    
    "yearlatest_mean", 
    "yearlatest_median",
    "yearlatest", 
    
    "yearfirst_mean",
    "yearfirst_median",
    
    "yearmean_mean",
    "yearmean_median",
    
    "n_lmic", 
    "p_lmic",
    
    "span_years", 
    "cov_years", 
    
    "nonmiss", 
    "nonmiss_tot", 
    "nonmiss_tot2000")

var_descr <- 
  c("First year", 
    "Total obs.", 
    "Number of years", 
    "Avg. country obs.", 
    "Max. country obs.", 
    
    "Mean of latest year", 
    "Med. of latest year", 
    "Latest year", 
    
    "Mean of first year", 
    "Med. of first year", 
    
    "Mean of mean year", 
    "Med. of mean year", 
    
    "Number of LMICs", 
    "% of LMICs", 
    
    "Year span", 
    "Year coverage", 
    
    "Non-missing", 
    "Non-missing, total", 
    "Non-missing, total since 2000")

var_df <- 
  data.frame(var_selection = var_selection, 
             var_descr     = var_descr)

```


## Row 



```{r beeswarm-plot}
score_table <- score_table %>%
  mutate(name_flag = "WDI Indicators")

p      <- plot_ly()
n_vars <- nrow(var_df)

make_visible_vec <- function(i, n_vars) {
  out <- rep(FALSE, 3 * n_vars)
  # The triple (3i-2, 3i-1, 3i) belongs to variable i
  out[(3*i - 2):(3*i)] <- TRUE
  out
}

for (i in seq_len(n_vars)) {
  
  var_nm    <- var_df$var_selection[i]
  var_label <- var_df$var_descr[i]    
  
  # Rename the chosen column to 'metric'
  df_i <- score_table %>%
    rename(metric = all_of(var_nm)) %>%
    mutate(
      # Minimal random jitter
      x_jitter = 1 + runif(n(), min=-0.1, max=0.1),
      text_tooltip = paste0(
        "Indicator: ", Indicator.Name, "<br>",
        var_label, ": ", metric
      )
    )
  
  # Mean for the horizontal line
  var_mean <- mean(df_i$metric, na.rm = TRUE)
  mean_label <- paste0("Mean: ", round(var_mean, 2))
  
  # 1) Points trace
  p <- p %>%
    add_trace(
      data       = df_i,
      x          = ~x_jitter,
      y          = ~metric,
      type       = "scatter",
      mode       = "markers",
      marker     = list(color = "#457b9d", opacity = 0.5),
      hoverinfo  = "text",
      text       = ~text_tooltip,
      name       = paste0(var_label, "_points"),
      visible    = (i == 1)
    )
  
  # 2) Horizontal mean line
  p <- p %>%
    add_trace(
      x          = c(0.87, 1.13),
      y          = rep(var_mean, 2),
      type       = "scatter",
      mode       = "lines",
      line       = list(color = "black"),
      hoverinfo  = "none",
      name       = paste0(var_label, "_mean_line"),
      visible    = (i == 1)
    )
  
  # 3) Text label
  p <- p %>%
    add_trace(
      x          = 1.13,
      y          = var_mean,
      type       = "scatter",
      mode       = "text",
      text       = mean_label,
      textposition = "middle right",
      hoverinfo  = "none",
      textfont   = list(color = "black"),
      showlegend = FALSE,
      name       = paste0(var_label, "_mean_text"),
      visible    = (i == 1)
    )
}

# Build the updatemenus
buttons <- lapply(seq_len(n_vars), function(i) {
  var_label <- var_df$var_descr[i]
  list(
    label  = var_label,   # displayed in the dropdown
    method = "update",
    args   = list(
      list(visible = make_visible_vec(i, n_vars)),
      list(
        title = paste0("Plot of ", var_label, " for all WDI Indicators"),
        yaxis = list(title = var_label)
      )
    )
  )
})

updatemenus <- list(
  list(
    type   = "dropdown",
    active = 0,
    buttons= buttons
  )
)

# Final layout
p <- p %>%
  layout(
    title      = paste0("Plot of ", 
                        tolower(var_df$var_descr[1]), 
                        " for all WDI Indicators"),
    showlegend = FALSE,
    xaxis = list(
      zeroline       = FALSE,
      showticklabels = FALSE, 
      title          = ""
    ),
    yaxis = list(title = var_df$var_descr[1]),
    updatemenus = updatemenus
  )

p



```



<!-- # Metadata -->

<!-- To help users understand the data, a set of key metadata fields need to be in place. At a minimum this includes a clear indicator name, description, definition, description of development relevance,  statistical concepts, methodology, data sources.  -->

<!-- - To display only the indicators missing required metadata fields, select the checkbox under the **'Missing Key Metadata Field'** column. -->

<!-- - Indicators with a score below 2 are highlighted. For a detailed explanation of the methodology, refer to the [Quantitative Scoring](#quantitative-scoring) section. -->

<!-- ```{r} -->
<!-- #| title: Metadata Table -->

<!-- meta_table <- select(score_table, Indicator.Code, Indicator.Name, metadata_score_hybrid, metadata_fail, metadata_length, Development.relevance, Statistical.concept.and.methodology, License.Type, Short.definition, Long.definition, Source,datatopic)  -->

<!-- # Function for select input filter -->
<!-- filter_fct <- function(values, name) { -->
<!--   tags$select( -->
<!--     tags$option(value = "", "All"), -->
<!--     purrr::map(unique(values), tags$option), -->
<!--     onchange = glue::glue( -->
<!--       "Reactable.setFilter( -->
<!--         'meta-tbl',  -->
<!--         '{name}',  -->
<!--         event.target.value   -->
<!--       )" -->
<!--     ), -->
<!--     style = "width: 100%;" -->
<!--   ) -->
<!-- } -->

<!-- filter_range <- function(values, name) { -->
<!--   oninput <- sprintf("Reactable.setFilter('meta-tbl', '%s', this.value)", name) -->
<!--   tags$input( -->
<!--     type = "range", -->
<!--     min = floor(min(values, na.rm = TRUE)),  # Handle NA values -->
<!--     max = ceiling(max(values, na.rm = TRUE)),  # Handle NA values -->
<!--     value = floor(min(values, na.rm = TRUE)), -->
<!--     oninput = oninput, -->
<!--     onchange = oninput, -->
<!--     "aria-label" = sprintf("Filter by minimum %s", name), -->
<!--     style = "width: 100%;" -->
<!--   ) -->
<!-- } -->

<!-- checkbox_filter_meta <- function(name) { -->
<!--   tags$label( -->
<!--     style = "display: block; margin-bottom: 10px;", -->
<!--     tags$input( -->
<!--       type = "checkbox", -->
<!--       id = paste0(name, "-checkbox"), -->
<!--       onchange = glue::glue( -->
<!--         "Reactable.setFilter( -->
<!--           'meta-tbl', -->
<!--           '{name}', -->
<!--           this.checked ? 'filter' : undefined -->
<!--         )" -->
<!--       ), -->
<!--       style = "margin-right: 5px;" -->
<!--     ), -->
<!--     "Only show indicators lacking key metadata" -->
<!--   ) -->
<!-- } -->

<!-- reactable( -->
<!--   meta_table, -->
<!--   filterable = TRUE, -->
<!--   columns = list( -->
<!--     Indicator.Code = colDef(name = "Code"), -->
<!--     Indicator.Name = colDef(name = "Name"), -->
<!--     metadata_length = colDef(name = "Metadata Length"), -->
<!--     Development.relevance = colDef(name = "Development Relevance"), -->
<!--     Statistical.concept.and.methodology = colDef(name = "Statistical Concept and Methodology"), -->
<!--     License.Type = colDef(name = "License"), -->
<!--     Short.definition = colDef(name = "Short Definition"), -->
<!--     Long.definition = colDef(name = "Long Definition"), -->
<!--     Source = colDef(name = "Source"), -->
<!--     metadata_fail = colDef( -->
<!--       name = "Missing key Metadata Field", -->
<!--       filterable = TRUE, -->
<!--       filterMethod = JS(" -->
<!--         function(rows, columnId, value) { -->
<!--           if (value === 'filter') { -->
<!--             return rows.filter(function(row) { -->
<!--               return row.values[columnId] != null && row.values[columnId] !== 'No missing metadata'; -->
<!--             }); -->
<!--           } else { -->
<!--             return rows; -->
<!--           } -->
<!--         } -->
<!--       "), -->
<!--       filterInput = checkbox_filter_meta("metadata_fail") -->
<!--     ), -->
<!--     datatopic = colDef( -->
<!--       name = "Topic", -->
<!--       filterInput = filter_fct -->
<!--     ), -->
<!--     metadata_score_hybrid = colDef( -->
<!--       name = "Metadata Score", -->
<!--       filterable = TRUE, -->
<!--       filterMethod = JS(" -->
<!--         function(rows, columnId, filterValue) { -->
<!--           return rows.filter(function(row) { -->
<!--             return row.values[columnId] != null && row.values[columnId] >= filterValue; -->
<!--           }); -->
<!--         } -->
<!--       "), -->
<!--       filterInput = filter_range, -->
<!--       style = function(value) { -->
<!--         if (is.na(value)) { -->
<!--           NULL  # Do nothing for NA -->
<!--         } else if (value < 2) { -->
<!--           list(background = danger, color = "white") # Warning color -->
<!--         } else { -->
<!--           NULL -->
<!--         } -->
<!--       } -->
<!--     ) -->
<!--   ), -->
<!--   defaultPageSize = 10, -->
<!--   elementId = "meta-tbl" -->
<!-- ) -->

<!-- ``` -->

<!-- # License -->

<!-- Data should be open and free to use. The World Bank has adopted the Creative Commons Attribution 4.0 International License (CC BY 4.0) for all its data. This license allows users to copy, distribute, transmit, and adapt the data, provided the source is appropriately cited. -->

<!-- - To display only the indicators lacking CC BY 4.0 license, select the checkbox under the **License** column. -->

<!-- ```{r} -->
<!-- license_table <-  score_table %>% -->
<!--     select(Indicator.Code, Indicator.Name,  License.Type, Source,  datatopic) %>% -->
<!--       arrange(License.Type) -->

<!-- # Function for select input filter -->
<!-- checkbox_filter_license <- function(name) { -->
<!--   tags$label( -->
<!--     style = "display: block; margin-bottom: 10px;", -->
<!--     tags$input( -->
<!--       type = "checkbox", -->
<!--       id = paste0(name, "-checkbox"), -->
<!--       onchange = glue::glue( -->
<!--         "Reactable.setFilter( -->
<!--           'license-tbl', -->
<!--           '{name}', -->
<!--           this.checked ? 'filter' : undefined -->
<!--         )" -->
<!--       ), -->
<!--       style = "margin-right: 5px;" -->
<!--     ), -->
<!--     "Only show indicators lacking CC BY 4.0" -->
<!--   ) -->
<!-- } -->

<!-- filter_fct_license <- function(values, name) { -->
<!--   tags$select( -->
<!--     tags$option(value = "", "All"), -->
<!--     purrr::map(unique(values), tags$option), -->
<!--     onchange = glue::glue( -->
<!--       "Reactable.setFilter( -->
<!--         'license-tbl',  -->
<!--         '{name}',  -->
<!--         event.target.value   -->
<!--       )" -->
<!--     ), -->
<!--     style = "width: 100%;" -->
<!--   ) -->
<!-- } -->

<!-- reactable( -->
<!--   license_table, -->
<!--   filterable = TRUE, -->
<!--   columns = list( -->
<!--     Indicator.Code = colDef(name = "Code"), -->
<!--     Indicator.Name = colDef(name = "Name"), -->
<!--     Source = colDef(name = "Source"), -->
<!--     datatopic = colDef( -->
<!--       name = "Topic", -->
<!--       filterInput = filter_fct_license -->
<!--     ), -->
<!--     License.Type = colDef( -->
<!--       name = "License", -->
<!--       filterable = TRUE, -->
<!--       filterMethod = JS(" -->
<!--         function(rows, columnId, value) { -->
<!--           if (value === 'filter') { -->
<!--             return rows.filter(function(row) { -->
<!--               return row.values[columnId] !== 'CC BY-4.0'; -->
<!--             }); -->
<!--           } else { -->
<!--             return rows; -->
<!--           } -->
<!--         } -->
<!--       "), -->
<!--       filterInput = checkbox_filter_license("License.Type") -->
<!--     ) -->
<!--   ), -->
<!--   defaultPageSize = 10, -->
<!--   elementId = "license-tbl" -->
<!-- ) -->
<!-- ``` -->

<!-- # User Metrics -->

<!-- The number of unique visitors to an indicator is a key metric to understand the usage of the indicator. This metric is calculated using the Adobe Analytics platform. -->

<!-- - To display only the indicators with less than 50 visitors last 12 months, select the checkbox under the **'Visitors'** column. -->

<!-- - Indicators with a score below 2 are highlighted. For a detailed explanation of the methodology, refer to the [Quantitative Scoring](#quantitative-scoring) section. -->

<!-- ```{r} -->
<!-- #| title: User Table -->

<!-- user_table <- score_table %>% -->
<!--   select( -->
<!--     Indicator.Code,  -->
<!--     Indicator.Name,  -->
<!--     uniquevisitors_score_hybrid,  -->
<!--     visitors,  -->
<!--     uniquevisitors,  -->
<!--     pageviews,  -->
<!--     datatopic -->
<!--   ) %>% -->
<!--   arrange(desc(uniquevisitors)) -->

<!-- # Function for select input filter -->
<!-- filter_fct_user <- function(values, name) { -->
<!--   tags$select( -->
<!--     tags$option(value = "", "All"), -->
<!--     purrr::map(unique(values), tags$option), -->
<!--     onchange = glue::glue( -->
<!--       "Reactable.setFilter( -->
<!--         'user-tbl',  -->
<!--         '{name}',  -->
<!--         event.target.value   -->
<!--       )" -->
<!--     ), -->
<!--     style = "width: 100%;" -->
<!--   ) -->
<!-- } -->

<!-- filter_range_user <- function(values, name) { -->
<!--   oninput <- sprintf("Reactable.setFilter('user-tbl', '%s', this.value)", name) -->
<!--   tags$input( -->
<!--     type = "range", -->
<!--     min = floor(min(values, na.rm = TRUE)),   -->
<!--     max = ceiling(max(values, na.rm = TRUE)),   -->
<!--     value = floor(min(values, na.rm = TRUE)), -->
<!--     oninput = oninput, -->
<!--     onchange = oninput, -->
<!--     "aria-label" = sprintf("Filter by minimum %s", name), -->
<!--     style = "width: 100%;" -->
<!--   ) -->
<!-- } -->

<!-- checkbox_filter_user <- function(name) { -->
<!--   tags$label( -->
<!--     style = "display: block; margin-bottom: 10px;", -->
<!--     tags$input( -->
<!--       type = "checkbox", -->
<!--       id = paste0(name, "-checkbox"), -->
<!--       onchange = glue::glue( -->
<!--         "Reactable.setFilter( -->
<!--           'user-tbl', -->
<!--           '{name}', -->
<!--           this.checked ? 'filter' : undefined -->
<!--         )" -->
<!--       ), -->
<!--       style = "margin-right: 5px;" -->
<!--     ), -->
<!--     "Only show indicators with less than 50 visitors last 12 months" -->
<!--   ) -->
<!-- } -->

<!-- reactable( -->
<!--   user_table, -->
<!--   filterable = TRUE, -->
<!--   columns = list( -->
<!--     Indicator.Code = colDef(name = "Code"), -->
<!--     Indicator.Name = colDef(name = "Name"), -->
<!--     visitors = colDef( -->
<!--       name = "Visitors", -->
<!--       filterable = TRUE, -->
<!--       filterMethod = JS(" -->
<!--         function(rows, columnId, value) { -->
<!--           if (value === 'filter') { -->
<!--             return rows.filter(function(row) { -->
<!--               return row.values[columnId] != null && row.values[columnId] < 50; -->
<!--             }); -->
<!--           } else { -->
<!--             return rows; -->
<!--           } -->
<!--         } -->
<!--       "), -->
<!--       filterInput = checkbox_filter_user("visitors") -->
<!--     ), -->
<!--     uniquevisitors = colDef(name = "Unique Visitors"), -->
<!--     pageviews = colDef(name = "Page Views"), -->
<!--     datatopic = colDef( -->
<!--       name = "Topic", -->
<!--       filterInput = filter_fct_user -->
<!--     ), -->
<!--     uniquevisitors_score_hybrid = colDef( -->
<!--       name = "Unique visitors Score", -->
<!--       filterable = TRUE, -->
<!--       filterMethod = JS("function(rows, columnId, filterValue) { -->
<!--         return rows.filter(function(row) { -->
<!--           return row.values[columnId] != null && row.values[columnId] >= filterValue; -->
<!--         }); -->
<!--       }"), -->
<!--       filterInput = filter_range_user, -->
<!--       style = function(value) { -->
<!--         if (is.na(value)) { -->
<!--           NULL   -->
<!--         } else if (value < 2) { -->
<!--           list(background = danger, color = "white")  # Warning color -->
<!--         } else { -->
<!--           NULL -->
<!--         } -->
<!--       } -->
<!--     ) -->
<!--   ), -->
<!--   defaultPageSize = 10, -->
<!--   elementId = "user-tbl" -->
<!-- ) -->

<!-- ``` -->

# Country Coverage

The number of countries for which data is available is a key metric to understand the geographical coverage of the indicator.

- To display only the indicators with poor country coverage (under 50 countries), select the checkbox under the **'Number of Countries'** column.

- Indicators with a score below 2 are highlighted. For a detailed explanation of the methodology, refer to the [Quantitative Scoring](#quantitative-scoring) section.

```{r}
#| title: Country Coverage Table

ctr_table <- select(score_table, 
                    Indicator.Code, 
                    Indicator.Name, 
                    geographic_score_hybrid, 
                    n_country, 
                    n_lmic,
                    p_lmic, 
                    datatopic) %>%
      arrange(desc(n_country))

# Function for select input filter
filter_fct_ctr <- function(values, name) {
  tags$select(
    tags$option(value = "", "All"),
    purrr::map(unique(values), tags$option),
    onchange = glue::glue(
      "Reactable.setFilter(
        'ctr-tbl', 
        '{name}', 
        event.target.value  
      )"
    ),
    style = "width: 100%;"
  )
}

filter_range_ctr <- function(values, name) {
  oninput <- sprintf("Reactable.setFilter('ctr-tbl', '%s', this.value)", name)
  tags$input(
    type = "range",
    min = floor(min(values, na.rm = TRUE)),  # Handle NA values
    max = ceiling(max(values, na.rm = TRUE)),  # Handle NA values
    value = floor(min(values, na.rm = TRUE)),
    oninput = oninput,
    onchange = oninput,
    "aria-label" = sprintf("Filter by minimum %s", name),
    style = "width: 100%;"
  )
}

checkbox_filter_ctr <- function(name) {
  tags$label(
    style = "display: block; margin-bottom: 10px;",
    tags$input(
      type = "checkbox",
      id = paste0(name, "-checkbox"),
      onchange = glue::glue(
        "Reactable.setFilter(
          'ctr-tbl',
          '{name}',
          this.checked ? 'filter' : undefined
        )"
      ),
      style = "margin-right: 5px;"
    ),
    "Only show indicators with fewer than 50 countries"
  )
}

reactable(
  ctr_table,  
  filterable = TRUE,
  columns = list(
    Indicator.Code = colDef(name = "Code"),
    Indicator.Name = colDef(name = "Name"),
    n_lmic = colDef(name = "Number of LMICs"),
    p_lmic = colDef(name = "Percent of LMICs"),
    n_country = colDef(
      name = "Number of Countries",
      filterable = TRUE,
      filterMethod = JS("
        function(rows, columnId, value) {
          if (value === 'filter') {
            return rows.filter(function(row) {
              return row.values[columnId] != null && row.values[columnId] < 50;
            });
          } else {
            return rows;
          }
        }
      "),
      filterInput = checkbox_filter_ctr("n_country")
    ),
    datatopic = colDef(
      name = "Topic",
      filterInput = filter_fct_ctr
    ),
    geographic_score_hybrid = colDef(
      name = "Geographical Coverage Score",
      filterable = TRUE,
      filterMethod = JS("
        function(rows, columnId, filterValue) {
          return rows.filter(function(row) {
            return row.values[columnId] != null && row.values[columnId] >= filterValue;
          });
        }
      "),
      filterInput = filter_range_ctr,
      style = function(value) {
        if (is.na(value)) {
          NULL  
        } else if (value < 2) {
          list(background = danger, color = "white")  # Warning color
        } else {
          NULL
        }
      }
    )
  ),
  defaultPageSize = 10,
  elementId = "ctr-tbl"
)

```

# Time Coverage

An indicator should have recent data available and the indicator should ideally be updated as frequently as possible.

- To display only the indicators with no data in the last 10 years, select the checkbox under the **'Latest Year'** column.

- Indicators with a score below 2 are highlighted. For a detailed explanation of the methodology, refer to the [Quantitative Scoring](#quantitative-scoring) section.

```{r}
#| title: Time Coverage Table

time_table <- select(score_table, Indicator.Code, Indicator.Name, temporal_score_hybrid, yearlatest, yearlatest_median, span_years, nonmiss, datatopic) %>%
      arrange(desc(yearlatest))

# Function for select input filter
filter_fct_time <- function(values, name) {
  tags$select(
    tags$option(value = "", "All"),
    purrr::map(unique(values), tags$option),
    onchange = glue::glue(
      "Reactable.setFilter(
        'time-tbl', 
        '{name}', 
        event.target.value  
      )"
    ),
    style = "width: 100%;"
  )
}

filter_range_time <- function(values, name) {
  oninput <- sprintf("Reactable.setFilter('time-tbl', '%s', this.value)", name)
  tags$input(
    type = "range",
    min = floor(min(values, na.rm = TRUE)),  # Handle NA values
    max = ceiling(max(values, na.rm = TRUE)),  # Handle NA values
    value = floor(min(values, na.rm = TRUE)),
    oninput = oninput,
    onchange = oninput,
    "aria-label" = sprintf("Filter by minimum %s", name),
    style = "width: 100%;"
  )
}

# Define checkbox filter for time
checkbox_filter_time <- function(name) {
  tags$label(
    style = "display: block; margin-bottom: 10px;",
    tags$input(
      type = "checkbox",
      id = paste0(name, "-checkbox"),
      onchange = glue::glue(
        "Reactable.setFilter(
          'time-tbl',
          '{name}',
          this.checked ? 'filter' : undefined
        )"
      ),
      style = "margin-right: 5px;"
    ),
    "Only show indicators with no data in the last 10 years"
  )
}

reactable(
  time_table,  
  filterable = TRUE,
  columns = list(
    Indicator.Code = colDef(name = "Code"),
    Indicator.Name = colDef(name = "Name"),
    yearlatest = colDef(
      name = "Latest Year",
      filterable = TRUE,
      filterMethod = JS("
        function(rows, columnId, value) {
          if (value === 'filter') {
            const cutoffYear = new Date().getFullYear() - 10;
            return rows.filter(function(row) {
              return row.values[columnId] < cutoffYear;
            });
          } else {
            return rows;
          }
        }
      "),
      filterInput = checkbox_filter_time("yearlatest")
    ),
    yearlatest_median = colDef(name = "Median Latest Year"),
    span_years = colDef(name = "Span of Years"),
    nonmiss = colDef(name = "Share of Non-missing Data"),
    datatopic = colDef(
      name = "Topic",
      filterInput = filter_fct_time
    ),
    temporal_score_hybrid = colDef(
      name = "Temporal Coverage Score",
      filterable = TRUE,
      filterMethod = JS("
        function(rows, columnId, filterValue) {
          return rows.filter(function(row) {
            return row.values[columnId] != null && row.values[columnId] >= filterValue;
          });
        }
      "),
      filterInput = filter_range_time,
      style = function(value) {
        if (is.na(value)) {
          NULL  
        } else if (value < 2) {
          list(background = danger, color = "white")  # Warning color
        } else {
          NULL
        }
      }
    )
  ),
  defaultPageSize = 10,
  elementId = "time-tbl"
)


```
# Quantitative Scoring

To quantify the quality of a WDI database indicator, we have created some metrics that help us understand the temporal coverage, geographical coverage, completeness, and usage of the indicator. We have created the following metrics:

<b>Geographical coverage:  </b>

  a. **Number of economies** (n\_country): This metric measures the total number of economies for which data is available for the indicator.    
  b. **Share of low- and middle-income economies** (p\_lmic): This metric measures the percent of low- and middle-income economies for which data is available. We use the total number of LMICs as of today as the denominator.
  
 <b>Temporal coverage:  </b>
 
  a. **Absolute latest year** (yearlatest): This metric measures the most recent year of data available for an indicator.    
  c. **Median latest year** (yearleatest\_median): This metric takes the most recent year of data available for each country for the indicator and then calculate the median.   
  d. **Span of years** (span\_years): This metric measures the total number of years for which data is available for this indicator. We take the first year data and latest year for which any data is available and calculating the span between these years.
  e. **Non-missing data:** This metric measures the share of non-missing data within its availability. The span is restricted to the indicator span and country coverage previously calculated, and not the span and coverage of the WDI.


<b>Usage:   </b>

  a. **Unique visitors:** This metric measures the number of unique visitors in one year which is calculated using the API for the Adobe Analytics platform.

<b>Metadata: </b>

  a. **Key Availability** This indicator checks that key metadata fields are available for the indicator, specifically fields on development relevance, methodology, license, definition, and source.  This is done by checking for the availability of at least one word in each of these fields.  The metric is between 0-5, with 1 point awarded for each field that has content available.
  b. **Length** This metric is a word count for an indicator across all metadata fields.  This includes development relevance, licenses, methodology, definition, source, comments, notes, and limitation.

These 9 metrics has been used to calculate scores for each indicator by two different methods. The following describes the two types of scoring methods:

<b> Distance to frontier scoring </b>

This approach takes the &#39;best case&#39; scenario and &#39;worst case&#39; scenario for each indicator, and calculates the distance of the actual value between the best and worst case. This is done by creating a percentage for each indicator.

For example, for &#39;Latest year&#39;, the best case value is 2020 and the worst case value is 2008, then if the indicator has a value of 2016, then the score for this indicator will be 2016-2008/2020-2008\*100 = 66.67%.

Such a percentage is calculated for every indicator except for Unique visitors. For Unique visitors, a percentile is generated as there is no &#39;best case&#39; scenario that is independent of the distribution.

After getting a score out of 100 for each metric, it is summed up and divided by the number of metrics i.e. seven, to get a total score out of 100.

<b> Threshold scoring </b>

In this approach, a score is produced for each indicator based on whether it passes certain thresholds in each metric. Three thresholds are defined for each metric, which are named the &quot;Loose&quot;, &quot;Median&quot;, and &quot;Stringent&quot; scenarios. The &quot;Loose&quot; scenario is the easiest for an indicator to pass. For instance for the &quot;Number of economies&quot; metric, it requires that the indicator have data for at least 35 economies. The &quot;Median&quot; scenario is more difficult to pass. On the &quot;Number of economies&quot; metric, for instance, it requires that the indicator to have data for at least 50 economies. The &quot;Stringent&quot; scenario is the most difficult for an indicator to pass, requiring, as an example, at least 65 countries with data for the &quot;Number of economies&quot; metric. The thresholds were defined by the WDI criteria team based on looking for natural cuts in the data for each metric and based on internal team discussion on reasonable standards.


Table. Thresholds for Classifications in Tiers to Flag Poorly Performing Indicators as of 2024. 
 
| Metric                                        | **Lowest Tier** | **4th Tier** | **3rd Tier** | **2nd Tier** | **Top Tier**|
| --------------------------------------------- | ------- | --------- | ---------- | ------------- | ------- |
| **Number of economies**                       | 30      | 50        | 80         | 100           | 180     |
| **Share of low- and middle-income economies** | 10      | 30        | 40         | 65            | 90      |
| **Span of years**                             | 3       | 6         | 10         | 15            | 50      |
| **Absolute latest year**                      | 2012    | 2013      | 2015       | 2016          | 2019    |
| **Median latest year**                        | 2010    | 2012      | 2012       | 2015          | 2019    |
| **Non-missing data**                          | 8       | 10        | 12         | 15            | 60      |
| **Unique visitors**                           | 50      | 65        | 120        | 200           | 2000    |
| **Metadata Availability**                     | 1       | 2         | 3          | 4             | 5       |
| **Metadata Word Length**                      | 50      | 100       | 150        | 200           | 500     |


To produce an overall score for each indicator based on this approach, the following methodology was followed. For each metric, a score of 0-4 was produced based on the following scoring:

- 1 point: metric value falls below the &quot;4th Tier&quot; scenario threshold
- 2 points: metric value falls between the &quot;4th Tier&quot; and &quot;3rd Tier&quot; threshold
- 3 points: metric value falls between the &quot;3rd Tier&quot; and &quot;2nd Tier&quot; threshold
- 4 points: metric value above the &quot;2nd Tier&quot; threshold.

The result of this scoring is that each indicator has a 1-4 score along all 9 of the scoring metrics (Number of economies, Share of low- and middle-income economies, Absolute latest year, Median latest year, Span of years, Non-missing data, Unique visitors, metadata availability, metadata length). 

An overall score is then computed by taking the weighted average the scores across the 9 metrics with higher scores meaning the indicator performs better on average across the nine metrics. The scores are produced using the nested structure described above with five categories: Geographic Coverage, Temporal Coverage, Completeness, Usage. The weights are 1/5 to indicators grouped in the Geographic Coverage category, 1/5 to Temporal Coverage, 1/5 to Completeness, 1/5 to Usage, and 1/5 to metadata quality. Within each category, the category scores are produced taking the unweighted average of metrics in that category.

<b> Distance to Threshold Scoring Approach </b>

A third approach to scoring combines some aspects of the distance to frontier scoring method and the threshold scoring method. As with the threshold scoring method, a set of loose, median, and stringent scenarios are used to score the indicators. This is the approach displayed in the figure on the main page.

A flaw with the threshold scoring approach is that the discrete scoring on the 1-4 scale resulted in many tied scores for indicators. The Distance to Threshold approach rectifies this flaw by extending the discrete 1-4 scale to a continuous scale between 0 and 4. It does so by incorporating some of the elements of the distance to frontier method, where upper limits and lower limits are set based on each scenario (loose, median, stringent) and an indicator is scored by its distance between the upper and lower limit.

Additionally, two new categories are added: &quot;Low&quot; and &quot;High&quot;, which help smooth the distribution of scores below the &quot;Loose&quot; and above the &quot;Stringent&quot; scenarios. Indicators scoring below the &quot;Low&quot; are automatically given the lower possible score &#39;0&#39;, which indicators scoring above the &quot;High&quot; are automatically given the highest possible score &#39;4&#39;. The &quot;Low&quot; and &quot;High&quot; categories help account for outliers in the distribution of the metrics that may impact the scoring. To give a specific example, on unique visitors, suppose there is an indicator that receives over a million unique visitors in a year. In fact, the indicator &quot;GDP growth (annual %)&quot; does receive this total in a year. If a &quot;High&quot; category was not set, then this outlier would cause a large amount of bunching of scores for all indicators above the &quot;Stringent&quot; group, as the vast majority of indicators are very far from this indicator with 1 million visits. Therefore, a High category is introduced, where any indicator scoring above this limit will automatically receive 4 points, and indicators under this High will not see as much bunching due to the outlier observation.



For each metric, a score of 0-4 was produced based on the following scoring. First some notation. Let $\alpha_l$ be the lower limit and $\alpha_u$ be the upper limit. Also let $\gamma$  be the value of a metric (for instance the number of countries). Then the scores are the following:

- Metric value falls below the &quot;Low&quot; scenario threshold
  - Lower limit : Low possible value for any indicator
  - Upper limit : value of the &quot;Low&quot; scenario
  - Score: 0
- Metric value falls below the &quot;Loose&quot; scenario threshold and above &quot;Low&quot;
  - Lower limit : value of the &quot;Low&quot; scenario
  - Upper limit : value of the &quot;Loose&quot; scenario
  - Score: $(\gamma-\alpha_l)/(\alpha_u - \alpha_l)$
- Metric value falls between the &quot;Loose&quot; and &quot;Median&quot; threshold
  - Lower limit : value of the &quot;Loose&quot; scenario
  - Upper limit : value of the &quot;Median&quot; scenario
  - Score: 1+$(\gamma-\alpha_l)/(\alpha_u - \alpha_l)$
- Metric value falls between the &quot;Median&quot; and &quot;Stringent&quot; threshold
  - Lower limit : value of the &quot;Median&quot; scenario
  - Upper limit : value of the &quot;Stringent&quot; scenario
  - Score: 2+$(\gamma-\alpha_l)/(\alpha_u - \alpha_l)$
- Metric value above the &quot;Stringent&quot; but below &quot;High&quot; threshold.
  - Lower limit : value of the &quot;Stringent&quot; scenario
  - Upper limit : value of the &quot;High&quot; scenario
  - Score: 3 +$(\gamma-\alpha_l)/(\alpha_u - \alpha_l)$
- Metric value falls above the &quot;High&quot; scenario threshold
  - Lower limit : value of the &quot;High&quot; scenario
  - Upper limit : Maximum possible value for any indicator
  - Score: 4

The score for indicator on a specific metric (say number of countries) is the distance from the lower limit divided by the total distance between the upper and lower limit plus a constant. The constant distinguishes between different thresholds. Note that the value for is always between 0 and 1 and that indicators with metrics closer to the upper limit are closer to 1 and thus receive higher scores. This scoring system results in continuous scale between 0 and 4.

To give a specific example based on the number of countries criteria, an indicator with data for 21 countries would receive a score of $(21-20)/(35-20)=0.067$. An indicator with data for 45 countries would receive a score of $1+(45-35)/(50-35)=1.667$. An indicator with data for 200 countries would receive a score of $3+(190-65)/(200-65)=3.93$

The result of this scoring is that each indicator has a 0-4 score along all 9 of the scoring metrics (Number of economies, Share of low- and middle-income economies, Absolute latest year, Median latest year, Span of years, Non-missing data, Unique visitors, metadata availability, metadata length). 

An overall score is then computed by taking the weighted average the scores across the 9 metrics with higher scores meaning the indicator performs better on average across the nine metrics. The scores are produced using the nested structure described above with five categories: Geographic Coverage, Temporal Coverage, Completeness, Usage. The weights are 1/5 to indicators grouped in the Geographic Coverage category, 1/5 to Temporal Coverage, 1/5 to Completeness, 1/5 to Usage, and 1/5 to metadata quality. Within each category, the category scores are produced taking the unweighted average of metrics in that category.


```{r}
#| title: Table
#conver to a table using the gt package
 score_table %>%
    select(Indicator.Code, Indicator.Name, hybrid_score_wgtd, n_country, p_lmic, yearlatest_median, yearlatest, nonmiss, 
           span_years, uniquevisitors,metadata_availability, metadata_length, License.Type,  datatopic) %>%
      arrange(hybrid_score_wgtd) %>%
  gt() %>%
  tab_header(
    title = "Indicator Overview",
    subtitle = "Summary of WDI Indicators"
  ) %>%
  fmt_number(
    columns = c('n_country', 'p_lmic', 'nonmiss', 'hybrid_score_wgtd'),
    decimals = 2
  ) %>%
  fmt_date(
    columns = c('yearlatest_median', 'yearlatest'),
  ) %>%
  fmt_number(
    columns = c('span_years', 'uniquevisitors'),
    use_seps = TRUE
  ) %>%
  #add span
  tab_spanner(
    label = "Metadata",
    columns = c('metadata_availability', 'metadata_length')
  ) %>%
  tab_spanner(
    label = "Time",
    columns = c('yearlatest_median', 'yearlatest', 'span_years', 'nonmiss')
  ) %>%
  tab_spanner(
    label = "Country",
    columns = c('n_country', 'p_lmic')
  ) %>%
  #rename columns
  cols_label(
    Indicator.Code = "Code",
    Indicator.Name = "Name",
    hybrid_score_wgtd = "Score",
    n_country = "Countries",
    p_lmic = "LMIC (%)",
    yearlatest_median = "Latest Year (Median)",
    yearlatest = "Latest Year (Max)",
    nonmiss = "Non-missing data (%)",
    span_years = "Years Spanned",
    uniquevisitors = "Unique visitors",
    metadata_availability = "Metadata Availability",
    metadata_length = "Metadata Length",
    License.Type = "License",
    datatopic = "Topic"
  )  |>
  tab_source_note(source_note = md("Data from the World Development Indicators.")) |>
  opt_interactive(
    use_search=TRUE,
    use_filters=TRUE
  )
```